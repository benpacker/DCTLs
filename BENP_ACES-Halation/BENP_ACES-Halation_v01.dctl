// ACEScct 1.2 Halation
// utilises snippets from Paul Dore:
// https://github.com/baldavenger/ACES_DCTL/blob/master/ACES_LIB.h
// https://github.com/baldavenger/DCTLs/blob/master/Convolution/Mean_7x7.dctl

// DEFINE_UI_PARAMS(hal_size, Halation Size, DCTLUI_SLIDER_INT, 25, 0, 100, 0)
DEFINE_UI_PARAMS(hal_threshold, Halation Threshold, DCTLUI_SLIDER_FLOAT, 1.33, 1, 5, 0.001)
DEFINE_UI_PARAMS(red_blend, Red Blend, DCTLUI_SLIDER_FLOAT, 1.0, 0, 1, 0.001)
DEFINE_UI_PARAMS(green_blend, Green Blend, DCTLUI_SLIDER_FLOAT, 0.433, 0, 1, 0.001)
DEFINE_UI_PARAMS(blue_blend, Blue Blend, DCTLUI_SLIDER_FLOAT, 0.133, 0, 1, 0.001)

#include "ACES_LIB.h"

// __CONSTANT__ Chromaticities AP0 =
// { {0.7347f, 0.2653f}, {0.0f, 1.0f}, {0.0001f, -0.077f}, {0.32168f, 0.33767f} };
// __CONSTANT__ Chromaticities AP1 =
// { {0.713f, 0.293f}, {0.165f, 0.83f}, {0.128f, 0.044f}, {0.32168f, 0.33767f} };
//
//
// __DEVICE__ inline mat3 make_mat3( float3 A, float3 B, float3 C) {
// mat3 D;
// D.c0 = A; D.c1 = B; D.c2 = C;
// return D;
// }
//
// __DEVICE__ inline float3 mult_f3_f33( float3 X, mat3 A) {
// float r[3];
// float x[3] = {X.x, X.y, X.z};
// float a[3][3] = {{A.c0.x, A.c0.y, A.c0.z}, {A.c1.x, A.c1.y, A.c1.z}, {A.c2.x, A.c2.y, A.c2.z}};
// for( int i = 0; i < 3; ++i){
// r[i] = 0.0f;
// for( int j = 0; j < 3; ++j){
// r[i] = r[i] + x[j] * a[j][i];}}
// return make_float3(r[0], r[1], r[2]);
// }
//
// __DEVICE__ inline mat3 mult_f33_f33( mat3 A, mat3 B) {
// float r[3][3];
// float a[3][3] = {{A.c0.x, A.c0.y, A.c0.z},
// {A.c1.x, A.c1.y, A.c1.z},
// {A.c2.x, A.c2.y, A.c2.z}};
// float b[3][3] = {{B.c0.x, B.c0.y, B.c0.z},
// {B.c1.x, B.c1.y, B.c1.z},
// {B.c2.x, B.c2.y, B.c2.z}};
// for( int i = 0; i < 3; ++i){
// for( int j = 0; j < 3; ++j){
// r[i][j] = 0.0f;
// for( int k = 0; k < 3; ++k){
// r[i][j] = r[i][j] + a[i][k] * b[k][j];
// }}}
// mat3 R = make_mat3(make_float3(r[0][0], r[0][1], r[0][2]), make_float3(r[1][0], r[1][1], r[1][2]), make_float3(r[2][0], r[2][1], r[2][2]));
// return R;
// }
//
// __DEVICE__ inline mat3 invert_f33( mat3 A) {
// mat3 R;
// float result[3][3];
// float a[3][3] = {{A.c0.x, A.c0.y, A.c0.z}, {A.c1.x, A.c1.y, A.c1.z}, {A.c2.x, A.c2.y, A.c2.z}};
// float det = a[0][0] * a[1][1] * a[2][2] + a[0][1] * a[1][2] * a[2][0]
// + a[0][2] * a[1][0] * a[2][1] - a[2][0] * a[1][1] * a[0][2]
// - a[2][1] * a[1][2] * a[0][0] - a[2][2] * a[1][0] * a[0][1];
// if( det != 0.0f ){
// result[0][0] = a[1][1] * a[2][2] - a[1][2] * a[2][1]; result[0][1] = a[2][1] * a[0][2] - a[2][2] * a[0][1];
// result[0][2] = a[0][1] * a[1][2] - a[0][2] * a[1][1]; result[1][0] = a[2][0] * a[1][2] - a[1][0] * a[2][2];
// result[1][1] = a[0][0] * a[2][2] - a[2][0] * a[0][2]; result[1][2] = a[1][0] * a[0][2] - a[0][0] * a[1][2];
// result[2][0] = a[1][0] * a[2][1] - a[2][0] * a[1][1]; result[2][1] = a[2][0] * a[0][1] - a[0][0] * a[2][1];
// result[2][2] = a[0][0] * a[1][1] - a[1][0] * a[0][1];
// R = make_mat3(make_float3(result[0][0], result[0][1], result[0][2]), make_float3(result[1][0], result[1][1],
// result[1][2]), make_float3(result[2][0], result[2][1], result[2][2]));
// return mult_f_f33( 1.0f / det, R);
// }
// R = make_mat3(make_float3(1.0f, 0.0f, 0.0f), make_float3(0.0f, 1.0f, 0.0f), make_float3(0.0f, 0.0f, 1.0f));
// return R;
// }
//
// __DEVICE__ inline mat3 RGBtoXYZ( Chromaticities N) {
// mat3 M = make_mat3(make_float3(N.red.x, N.red.y, 1.0f - (N.red.x + N.red.y)),
// make_float3(N.green.x, N.green.y, 1.0f - (N.green.x + N.green.y)), make_float3(N.blue.x, N.blue.y, 1.0f - (N.blue.x + N.blue.y)));
// float3 wh = make_float3(N.white.x / N.white.y, 1.0f, (1.0f - (N.white.x + N.white.y)) / N.white.y);
// wh = mult_f3_f33(wh, invert_f33(M));
// mat3 WH = make_mat3(make_float3(wh.x, 0.0f, 0.0f), make_float3(0.0f, wh.y, 0.0f), make_float3(0.0f, 0.0f, wh.z));
// M = mult_f33_f33(WH, M);
// return M;
// }
//
// __DEVICE__ inline mat3 XYZtoRGB( Chromaticities N) {
// mat3 M = invert_f33(RGBtoXYZ(N));
// return M;
// }
//
// __DEVICE__ inline float lin_to_ACEScct( float in) {
// if (in <= X_BRK)
// return A * in + B;
// else
// return (_log2f(in) + 9.72f) / 17.52f;
// }
//
// __DEVICE__ inline float ACEScct_to_lin( float in) {
// if (in > Y_BRK)
// return _exp2f(in * 17.52f - 9.72f);
// else
// return (in - B) / A;
// }
//
// __DEVICE__ inline float3 ACES_to_ACEScct( float3 in) {
// float3 ap1_lin = mult_f3_f33( in, mult_f33_f33( RGBtoXYZ( AP0), XYZtoRGB( AP1)));
// float3 acescct;
// acescct.x = lin_to_ACEScct( ap1_lin.x); acescct.y = lin_to_ACEScct( ap1_lin.y); acescct.z = lin_to_ACEScct( ap1_lin.z);
// return acescct;
// }
//
// __DEVICE__ inline float3 ACEScct_to_ACES( float3 in) {
// float3 ap1_lin;
// ap1_lin.x = ACEScct_to_lin( in.x); ap1_lin.y = ACEScct_to_lin( in.y); ap1_lin.z = ACEScct_to_lin( in.z);
// return mult_f3_f33( ap1_lin, mult_f33_f33( RGBtoXYZ( AP1), XYZtoRGB( AP0)));
// }



__DEVICE__ float mean(float p_Table[], int m) {
float temp = 0.0f;
for(int i = 0; i < m; ++i) {
temp += p_Table[i]; }
return (temp / m);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB)
{

float3 ipt;
ipt.x = _tex2D(p_TexR, p_X, p_Y);
ipt.y = _tex2D(p_TexG, p_X, p_Y);
ipt.z = _tex2D(p_TexB, p_X, p_Y);
float3 ACES = ACEScct_to_ACES(ipt);

const int length = 17;
const int area = length * length;

float colRGB[3];
float TableR[area], TableG[area], TableB[area];

for (int i = 0; i < area; ++i) {
int offset = (length - 1) / 2;
int xx = (i >= length ? _fmod(i, length/1.0f) : i) - offset;
int yy = _floor(i / (length/1.0f)) - offset;

TableR[i] = _tex2D(p_TexR, p_X + xx, p_Y + yy);
TableG[i] = _tex2D(p_TexG, p_X + xx, p_Y + yy);
TableB[i] = _tex2D(p_TexB, p_X + xx, p_Y + yy);

float3 blur = make_float3(TableR[i], TableG[i], TableB[i]);
blur = ACEScct_to_ACES(blur);

TableR[i] = blur.x;
TableG[i] = blur.y;
TableB[i] = blur.z;
}

for (int c = 0; c < 3; ++c) {
colRGB[c] = c == 0 ? mean(TableR, area) : c == 1 ? mean(TableG, area) : mean(TableB, area);
}

float3 blur = make_float3(colRGB[0], colRGB[1], colRGB[2]);
blur = _powf(blur, hal_threshold);

float blend;

if (blur.x > ACES.x) {
  blend = _fdimf(blur.x, ACES.x) * (2.0f * red_blend);
  ACES.x = ((blend * blur.x) + (ACES.x * ( 1 - blend)));
}

if (blur.y > ACES.y) {
  blend = _fdimf(blur.y, ACES.y) * (2.0f * green_blend);
  ACES.y = ((blend * blur.y) + (ACES.y * ( 1 - blend)));
}

if (blur.z > ACES.z) {
  blend = _fdimf(blur.z, ACES.z) * (2.0f * blue_blend);
  ACES.z = ((blend * blur.z) + (ACES.z * ( 1 - blend)));
}

float3 opt = ACES_to_ACEScct(ACES);

return opt;

}
