// ACEScct 1.2 Halation
// utilises snippets from Paul Dore:
// https://github.com/baldavenger/ACES_DCTL/blob/master/ACES_LIB.h
// https://github.com/baldavenger/DCTLs/blob/master/Convolution/Mean_7x7.dctl

DEFINE_UI_PARAMS(hal_size, Halation Size, DCTLUI_SLIDER_INT, 25, 0, 100, 0)
DEFINE_UI_PARAMS(hal_threshold, Halation Threshold, DCTLUI_SLIDER_FLOAT, 1.33, 1, 5, 0.001)
DEFINE_UI_PARAMS(red_blend, Red Blend, DCTLUI_SLIDER_FLOAT, 1.0, 0, 1, 0.001)
DEFINE_UI_PARAMS(green_blend, Green Blend, DCTLUI_SLIDER_FLOAT, 0.433, 0, 1, 0.001)
DEFINE_UI_PARAMS(blue_blend, Blue Blend, DCTLUI_SLIDER_FLOAT, 0.133, 0, 1, 0.001)

#include "ACES_LIB.h"

__DEVICE__ float mean(float p_Table[], int m) {
float temp = 0.0f;
for(int i = 0; i < m; ++i) {
temp += p_Table[i]; }
return (temp / m);
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, __TEXTURE__ p_TexR, __TEXTURE__ p_TexG, __TEXTURE__ p_TexB)
{

float3 ipt;
ipt.x = _tex2D(p_TexR, p_X, p_Y);
ipt.y = _tex2D(p_TexG, p_X, p_Y);
ipt.z = _tex2D(p_TexB, p_X, p_Y);
float3 ACES = ACEScct_to_ACES(ipt);

int length = hal_size;
int area = length * length;

float colRGB[3];
float TableR[area], TableG[area], TableB[area];

for (int i = 0; i < area; ++i) {
int offset = (length - 1) / 2;
int xx = (i >= length ? _fmod(i, length/1.0f) : i) - offset;
int yy = _floor(i / (length/1.0f)) - offset;

TableR[i] = _tex2D(p_TexR, p_X + xx, p_Y + yy);
TableG[i] = _tex2D(p_TexG, p_X + xx, p_Y + yy);
TableB[i] = _tex2D(p_TexB, p_X + xx, p_Y + yy);

float3 blur = make_float3(TableR[i], TableG[i], TableB[i]);
blur = ACEScct_to_ACES(blur);

TableR[i] = blur.x;
TableG[i] = blur.y;
TableB[i] = blur.z;
}

for (int c = 0; c < 3; ++c) {
colRGB[c] = c == 0 ? mean(TableR, area) : c == 1 ? mean(TableG, area) : mean(TableB, area);
}

float3 blur = make_float3(colRGB[0], colRGB[1], colRGB[2]);
blur = _powf(blur, hal_threshold);

float blend;

if (blur.x > ACES.x) {
  blend = _fdimf(blur.x, ACES.x) * (2.0f * red_blend);
  ACES.x = ((blend * blur.x) + (ACES.x * ( 1 - blend)));
}

if (blur.y > ACES.y) {
  blend = _fdimf(blur.y, ACES.y) * (2.0f * green_blend);
  ACES.y = ((blend * blur.y) + (ACES.y * ( 1 - blend)));
}

if (blur.z > ACES.z) {
  blend = _fdimf(blur.z, ACES.z) * (2.0f * blue_blend);
  ACES.z = ((blend * blur.z) + (ACES.z * ( 1 - blend)));
}

float3 opt = ACES_to_ACEScct(ACES);

return opt;

}
