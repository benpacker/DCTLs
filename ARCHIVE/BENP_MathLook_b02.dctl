
// DEFINE CONSTANTS
__CONSTANT__ float pie = 3.14159265358979323f;
__CONSTANT__ float e = 2.718281828459045f;

// DECLARE COLOURSPACE CONVERSIONS
__DEVICE__ float3 rgb_2_yab(float3 rgb);
__DEVICE__ float3 yab_2_ych(float3 yab);
__DEVICE__ float3 rgb_2_ych(float3 rgb);
__DEVICE__ float3 yab_2_rgb(float3 yab);
__DEVICE__ float3 ych_2_rgb(float3 ych);
__DEVICE__ float3 ych_2_yab(float3 ych);
__DEVICE__ float3 rgb_2_hsv(float3 rgb);
__DEVICE__ float3 hsv_2_rgb(float3 hsv);

// // DECLARE SELECTIVE SHAPER TOOLS
__DEVICE__ float center_hue(float hue, float centerH);
__DEVICE__ float uncenter_hue(float hueCentered, float centerH);
__DEVICE__ float cubic_basis_shaper(float x, float w);
__DEVICE__ float interpolate1D (float2 table[], int Size, float p);
__DEVICE__ float gaussian_shaper(float x, float target, float w);
__DEVICE__ float sigmoid_shaper(float x, float target, float w);


// DEFINE COLOURSPACE CONVERSIONS
__DEVICE__ float3 rgb_2_yab(float3 rgb) {
  float3 yab;
  yab.x = (rgb.x * 0.333333f) + (rgb.y * 0.333333f) + (rgb.z * 0.333333f);
  yab.y = (rgb.x * 0.5f) + (rgb.y * -0.25f) + (rgb.z * -0.25f);
  yab.z = (rgb.x * 0.0f) + (rgb.y * 0.433013f) + (rgb.z * -0.433013f);
  return yab;
}

__DEVICE__ float3 yab_2_ych(float3 yab) {
  float3 ych;
  ych.x = yab.x;
  ych.y = _sqrtf( yab.y * yab.y + yab.z * yab.z );
  ych.z = _atan2f(yab.z, yab.y) * (180.0f / pie);
  if (ych.z < 0.0f) ych.z += 360.0f;
  return ych;
}

__DEVICE__ float3 rgb_2_ych(float3 rgb) {
  float3 yab;
  yab.x = (rgb.x * 0.333333f) + (rgb.y * 0.333333f) + (rgb.z * 0.333333f);
  yab.y = (rgb.x * 0.5f) + (rgb.y * -0.25f) + (rgb.z * -0.25f);
  yab.z = (rgb.x * 0.0f) + (rgb.y * 0.433013f) + (rgb.z * -0.433013f);
  float3 ych;
  ych.x = yab.x;
  ych.y = _sqrtf( yab.y * yab.y + yab.z * yab.z );
  ych.z = _atan2f(yab.z, yab.y) * (180.0f / pie);
  if (ych.z < 0.0f) ych.z += 360.0f;
  return ych;
}

__DEVICE__ float3 ych_2_yab(float3 ych) {
  float3 yab;
  yab.x = ych.x;
  yab.y = ych.y * _cosf(ych.z * (pie / 180.0f));
  yab.z = ych.y * _sinf(ych.z * (pie / 180.0f));
  return yab;
}

__DEVICE__ float3 yab_2_rgb(float3 yab) {
  float3 rgb;
  rgb.x = (yab.x * 1.0f) + (yab.y * 1.333333f) + (yab.z * 0.0f);
  rgb.y = (yab.x * 1.0f) + (yab.y * -0.666666f) + (yab.z * 1.154701f);
  rgb.z = (yab.x * 1.0f) + (yab.y * -0.666666f) + (yab.z * -1.154701f);
  return rgb;
}

__DEVICE__ float3 ych_2_rgb(float3 ych) {
  float3 yab;
  yab.x = ych.x;
  yab.y = ych.y * _cosf(ych.z * (pie / 180.0f));
  yab.z = ych.y * _sinf(ych.z * (pie / 180.0f));
  float3 rgb;
  rgb.x = (yab.x * 1.0f) + (yab.y * 1.333333f) + (yab.z * 0.0f);
  rgb.y = (yab.x * 1.0f) + (yab.y * -0.666666f) + (yab.z * 1.154701f);
  rgb.z = (yab.x * 1.0f) + (yab.y * -0.666666f) + (yab.z * -1.154701f);
  return rgb;
}

__DEVICE__ float3 rgb_2_hsv(float3 rgb) {
  float min = _fminf(_fminf(rgb.x, rgb.y), rgb.z);
  float max = _fmaxf(_fmaxf(rgb.x, rgb.y), rgb.z);
  float delta = max - min;
  float HH;
  float SS;
  float VV;
  if (delta == 0.f) {
    HH = 0.f;
  } else if (rgb.x == max) {
		HH = (rgb.y - rgb.z) / delta;
	} else if (rgb.y == max) {
		HH = 2 + (rgb.z - rgb.x) / delta;
	} else {
		HH = 4 + (rgb.x - rgb.y) / delta;
	}
  HH *= 1.0f / 6.;
  if (HH < 0) {
    HH += 1.0f;
  }
  if (max != 0.) {
    SS = delta / max;
	} else {
    SS = 0.f;
  }
  VV = max;

  float3 hsv = make_float3(HH, SS, VV);
  return hsv;
}

__DEVICE__ float3 hsv_2_rgb(float3 hsv) {
  float3 rgb;
  if (hsv.y == 0.0f) {
    rgb.x = rgb.y = rgb.z = hsv.z;
    return rgb;
  }
  hsv.x *= 6.0f;
	int i = _floor(hsv.x);
	float f = hsv.x - i;
	i = (i >= 0) ? (i % 6) : (i % 6) + 6;
	float p = hsv.z * (1.0f - hsv.y);
	float q = hsv.z * (1.0f - hsv.y * f);
	float t = hsv.z * (1.0f - hsv.y * (1.0f - f));
  rgb.x = i == 0 ? hsv.z : i == 1 ? q : i == 2 ? p : i == 3 ? p : i == 4 ? t : hsv.z;
	rgb.y = i == 0 ? t : i == 1 ? hsv.z : i == 2 ? hsv.z : i == 3 ? q : i == 4 ? p : p;
	rgb.z = i == 0 ? p : i == 1 ? p : i == 2 ? t : i == 3 ? hsv.z : i == 4 ? hsv.z : q;
  return rgb;
}


// DEFINE SELECTIVE SHAPER TOOLS
__DEVICE__ float center_hue( float hue, float centerH) {
float hueCentered = hue - centerH;
if (hueCentered < -180.0f) hueCentered = hueCentered + 360.0f;
else if (hueCentered > 180.0f) hueCentered = hueCentered - 360.0f;
return hueCentered;
}

__DEVICE__ float uncenter_hue( float hueCentered, float centerH) {
float hue = hueCentered + centerH;
if (hue < 0.0f) hue = hue + 360.0f;
else if (hue > 360.0f) hue = hue - 360.0f;
return hue;
}

__DEVICE__ float cubic_basis_shaper( float x, float w) {
float M[4][4] = { {-1.0f/6.0f, 3.0f/6.0f, -3.0f/6.0f, 1.0f/6.0f}, {3.0f/6.0f, -1.0f, 3.0f/6.0f, 0.0f},
{-3.0f/6.0f, 0.0f, 3.0f/6.0f, 0.0f}, {1.0f/6.0f, 4.0f/6.0f, 1.0f/6.0f, 0.0f} };
float knots[5] = {-w/2.0f, -w/4.0f, 0.0f, w/4.0f, w/2.0f};
float y = 0.0f;
if ((x > knots[0]) && (x < knots[4])) {
float knot_coord = (x - knots[0]) * 4.0f/w;
int j = knot_coord;
float t = knot_coord - j;
float monomials[4] = { t * t * t, t * t, t, 1.0f };
if ( j == 3) {
y = monomials[0] * M[0][0] + monomials[1] * M[1][0] + monomials[2] * M[2][0] + monomials[3] * M[3][0];
} else if ( j == 2) {
y = monomials[0] * M[0][1] + monomials[1] * M[1][1] + monomials[2] * M[2][1] + monomials[3] * M[3][1];
} else if ( j == 1) {
y = monomials[0] * M[0][2] + monomials[1] * M[1][2] + monomials[2] * M[2][2] + monomials[3] * M[3][2];
} else if ( j == 0) {
y = monomials[0] * M[0][3] + monomials[1] * M[1][3] + monomials[2] * M[2][3] + monomials[3] * M[3][3];
} else {
y = 0.0f;
}}
return y * 3.0f/2.0f;
}

__DEVICE__ float interpolate1D (float2 table[], int Size, float p) {
if( p <= table[0].x ) return table[0].y;
if( p >= table[Size-1].x ) return table[Size-1].y;
for( int i = 0; i < Size - 1; ++i ){
if( table[i].x <= p && p < table[i+1].x ){
float s = (p - table[i].x) / (table[i+1].x - table[i].x);
return table[i].y * ( 1 - s ) + table[i+1].y * s;
}}
return 0.0f;
}

__DEVICE__ float gaussian_shaper(float x, float target, float w) {
  float out;
  float base = 1.0f * e;
  float power = (_powf((x - target), 2)) / (_powf((2 * w), 2));
  out = _powf(base, -power);
  return out;
}

__DEVICE__ float sigmoid_shaper(float x, float target, float w) {
  float out;
  out = (1 / (1.0f + _powf(e, (-8.9f * w) * (x - target))));
  return out;
}

__DEVICE__ float3 Sat_Soft_Clip(float3 rgb, float softclip){
  float3 ych = rgb_2_ych(rgb);
  softclip *= 0.3f;
  if (ych.y > softclip) {
    ych.y = (-1.0f / ((ych.y - softclip) / (1.0f - softclip) + 1.0f) + 1.0f) * (1.0f - softclip) + softclip;
    }
  rgb = ych_2_rgb(ych);
  return rgb;
}





__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
  float3 in_rgb = make_float3(p_R, p_G, p_B);
  float3 in_yab = rgb_2_yab(in_rgb);
  float3 in_ych = rgb_2_ych(in_rgb);
  float3 in_hsv = rgb_2_hsv(in_rgb);
  float3 in_b4;

  float new_change;
  float3 target_hue;
  float3 target_sat;
  float3 target_val;
  float cntr_hue;
  float cntr_tgt;
  float HH;
  float SS;
  float VV;

  // PRECHANGE_01 - SATURATION (target, softness, change)
  target_sat = make_float3(0.5f, 0.5f, 1.6f);
  float3 PRECHANGE = in_hsv;
  float pre_alpha = gaussian_shaper(in_hsv.y, target_sat.x, target_sat.y);
  PRECHANGE.y = _fmaxf((in_hsv.y * target_sat.z * pre_alpha), in_hsv.y);
  PRECHANGE = hsv_2_rgb(PRECHANGE);

  // PRE COLOURSPACES
  float3 pre_rgb = PRECHANGE;
  float3 pre_yab = rgb_2_yab(PRECHANGE);
  float3 pre_ych = rgb_2_ych(PRECHANGE);
  float3 pre_hsv = rgb_2_hsv(PRECHANGE);



  //CHANGE_01 - YELLOW TWEAK (target, width, change)
  target_hue = make_float3(65.0f, 150.0f, 75.0f);
  cntr_hue = center_hue(pre_ych.z, target_hue.x);
  cntr_tgt = center_hue(pre_ych.z, target_hue.z);
  HH = cubic_basis_shaper(cntr_hue, target_hue.y);
  float c01_alpha = HH;
  float3 c01;
  float3 c01_ych = pre_ych;

  if (HH > 0.0f) c01_ych.z = uncenter_hue(((HH * cntr_tgt) + (cntr_hue * ( 1 - HH))), target_hue.x);

  c01 = ych_2_rgb(c01_ych);



  //CHANGE_02 - CYAN TWEAK (target, width, change)
  target_hue = make_float3(175.0f, 350.0f, 165.0f);
  cntr_hue = center_hue(pre_ych.z, target_hue.x);
  cntr_tgt = center_hue(pre_ych.z, target_hue.z);
  HH = cubic_basis_shaper(cntr_hue, target_hue.y);
  SS = gaussian_shaper(pre_hsv.y, 1.0f, 2.0f);
  float c02_alpha = HH * SS;
  float3 c02;
  float3 c02_ych = pre_ych;
  float3 c02_hsv = pre_hsv;

  if (HH > 0.0f) c02_ych.z = uncenter_hue(((HH * cntr_tgt) + (cntr_hue * ( 1 - HH))), target_hue.x);
  c02_hsv.y = _fmaxf((pre_hsv.y * 2.0f * c02_alpha), pre_hsv.y);
  c02_ych = ych_2_rgb(c02_ych);
  c02_hsv = hsv_2_rgb(c02_hsv);
  c02 = (c02_ych + c02_hsv) / 2;



  //CHANGE_03 - GREEN TWEAK (target, width, change)
  target_hue = make_float3(135.0f, 300.0f, 90.0f);
  target_sat = make_float3(0.5f, 0.5f, 1.3f);
  cntr_hue = center_hue(pre_ych.z, target_hue.x);
  cntr_tgt = center_hue(pre_ych.z, target_hue.z);
  HH = cubic_basis_shaper(cntr_hue, target_hue.y);
  SS = sigmoid_shaper(pre_hsv.y, target_sat.x, target_sat.y);
  float c03_alpha = HH * SS;
  float3 c03;
  float3 c03_ych = pre_ych;
  float3 c03_hsv = pre_hsv;

  if (HH > 0.0f) c03_ych.z = uncenter_hue(((HH * cntr_tgt) + (cntr_hue * ( 1 - HH))), target_hue.x);
  c03_ych.x = ((c03_alpha * (c03_alpha * pre_ych.x / 1.2f)) + (pre_ych.x * (1 - c03_alpha)));

  c03 = ych_2_rgb(c03_ych);



  // CHANGE_04 - SKIN AVERAGE (target, width, change)
  target_hue = make_float3(18.1f, 70.0f, 13.1f);
  target_sat = make_float3(0.2f, 0.6f, 0.8f);
  target_val = make_float3(0.25f, 0.45f, 0.6f);
  cntr_hue = center_hue(pre_ych.z, target_hue.x);
  cntr_tgt = center_hue(pre_ych.z, target_hue.z);
  HH = cubic_basis_shaper(cntr_hue, target_hue.y);
  SS = gaussian_shaper(pre_hsv.y, target_sat.x, target_sat.y);
  VV = gaussian_shaper(pre_hsv.z, target_val.x, target_val.y);
  float c04_alpha = HH * SS * VV;
  float3 c04;
  float3 c04_ych = pre_ych;
  float3 c04_hsv = pre_hsv;

  if (HH > 0.0f) c04_ych.z = uncenter_hue(cntr_tgt, target_hue.x);
  c04_hsv.y = pre_hsv.y * target_sat.z;
  c04_hsv.z = (VV * c04_hsv.z) + (target_val.z * (1 - VV));
  c04_hsv = hsv_2_rgb(c04_hsv);
  c04_ych = ych_2_rgb(c04_ych);

  c04.x = (c04_alpha * ((c04_ych.x + c04_hsv.x) / 2)) + (pre_rgb.x * (1 - c04_alpha));
  c04.y = (c04_alpha * ((c04_ych.y + c04_hsv.y) / 2)) + (pre_rgb.y * (1 - c04_alpha));
  c04.z = (c04_alpha * ((c04_ych.z + c04_hsv.z) / 2)) + (pre_rgb.z * (1 - c04_alpha));




  // POSTCHANGE_01 - CLAMP (target, softness, change)
  target_sat = make_float3(0.0f, 0.05f, 0.5f);
  SS = gaussian_shaper(in_hsv.y, target_sat.x, target_sat.y);
  float post_alpha = c01_alpha + c02_alpha + c03_alpha + c04_alpha;
  float3 POSTCHANGE;
  POSTCHANGE.x = ((c01_alpha * c01.x) + (c02_alpha * c02.x) + (c03_alpha * c03.x) + (c04_alpha * c04.x)) / post_alpha;
  POSTCHANGE.y = ((c01_alpha * c01.y) + (c02_alpha * c02.y) + (c03_alpha * c03.y) + (c04_alpha * c04.y)) / post_alpha;
  POSTCHANGE.z = ((c01_alpha * c01.z) + (c02_alpha * c02.z) + (c03_alpha * c03.z) + (c04_alpha * c04.z)) / post_alpha;
  POSTCHANGE.x = (SS * in_rgb.x) + (POSTCHANGE.x * ( 1 - SS));
  POSTCHANGE.y = (SS * in_rgb.y) + (POSTCHANGE.y * ( 1 - SS));
  POSTCHANGE.z = (SS * in_rgb.z) + (POSTCHANGE.z * ( 1 - SS));
  POSTCHANGE = Sat_Soft_Clip( POSTCHANGE, 0.9f);
  return POSTCHANGE;
}
